# -*- coding: utf-8 -*-

__author__ = 'Łukasz Dębek'

from qgis.core import QGis


class RasGisImport(object):
    """
    Exporting model to RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.header = HeaderBuilder(rgis)
        self.network = NetworkBuilder(rgis)
        self.xsections = XSBuilder(rgis)
        self.levees = LeveesBuilder(rgis)
        self.ineff_areas = IneffAreasBuilder(rgis)
        self.blocked_obs = BlockedObsBuilder(rgis)

    def gis_import_file(self):
        imp = self.header.build_header()
        imp += self.network.build_network()
        imp += self.xsections.build_cross_sections()
        imp += self.levees.build_levees()
        imp += self.ineff_areas.build_ineff_areas()
        imp += self.blocked_obs.build_blocked_obs()
        return imp

    @staticmethod
    def unpack_wkt(wkt):
        if wkt.startswith('POINT'):
            sidx = 6
            eidx = -1
        elif wkt.startswith('LINESTRING'):
            sidx = 11
            eidx = -1
        elif wkt.startswith('POLYGON'):
            sidx = 9
            eidx = -2
        else:
            raise ValueError('Inappropariate WKT geometry type. WKT must be POINT, LINSTRING or POLYGON.')
        pnts = (p.split() for p in wkt[sidx:eidx].split(','))
        return pnts


class HeaderBuilder(object):
    """
    Return header of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.dbname = rgis.rdb.dbname
        self.host = rgis.rdb.host
        self.schema = rgis.rdb.SCHEMA
        self.srid = rgis.rdb.SRID

    def number_of_reaches(self):
        qry = 'SELECT COUNT("ReachID") FROM "{0}"."StreamCenterlines";'
        qry = qry.format(self.schema)
        nor = int(self.rgis.rdb.run_query(qry, fetch=True)[0][0])
        if self.rgis.DEBUG:
            self.rgis.addInfo('Nr of reaches: {0:d}'.format(nor))
        return nor

    def number_of_xsections(self):
        qry = 'SELECT COUNT("XsecID") FROM "{0}"."XSCutLines";'
        qry = qry.format(self.schema)
        nox = int(self.rgis.rdb.run_query(qry, fetch=True)[0][0])
        if self.rgis.DEBUG:
            self.rgis.addInfo('Nr of cross-sections: {0:d}'.format(nox))
        return nox

    def spatial_extent(self):
        qry = 'SELECT ST_Extent(geom) FROM "{0}"."XSCutLines";'
        qry = qry.format(self.schema)
        box = self.rgis.rdb.run_query(qry, fetch=True)[0][0]
        box_min = box[box.index('(')+1:box.index(',')].split()
        box_max = box[box.index(',')+1:box.index(')')].split()
        ext = 'XMIN: {0}\n      YMIN: {1}\n      XMAX: {2}\n      YMAX: {3}\n   '
        se = ext.format(box_min[0], box_min[1], box_max[0], box_max[1])
        if self.rgis.DEBUG:
            self.rgis.addInfo(se)
        return se

    def spatial_unit(self):
        u = self.rgis.crs.mapUnits()
        su = QGis.toLiteral(u).upper()
        return su

    def build_header(self):
        hdr = '''#This file is generated by RiverGIS, a QGIS plugin (http://rivergis.com)
BEGIN HEADER:
   DTM TYPE: GRID
   DTM:
   STREAM LAYER: {0}@{1}/{2}/StreamCenterlines
   NUMBER OF REACHES: {3:d}
   CROSS-SECTION LAYER: {0}@{1}/{2}/XSCutLines
   NUMBER OF CROSS-SECTIONS: {4:d}
   MAP PROJECTION:
   PROJECTION ZONE:
   DATUM:
   VERTICAL DATUM:
   BEGIN SPATIAL EXTENT:
      {5}END SPATIAL EXTENT:
      UNITS: {6}
END HEADER:

'''
        nor = self.number_of_reaches()
        nox = self.number_of_xsections()
        se = self.spatial_extent()
        su = self.spatial_unit()
        hdr = hdr.format(self.dbname, self.host, self.schema, nor, nox, se, su)
        return hdr


class NetworkBuilder(object):
    """
    Return STREAM NETWORK part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_nodes(self):
        qry = 'SELECT "NodeID", "X", "Y" FROM "{0}"."NodesTable";'
        qry = qry.format(self.schema)
        nodes = self.rgis.rdb.run_query(qry, fetch=True)
        return nodes

    def get_reaches(self):
        qry = '''
SELECT
    "ReachID",
    "RiverCode",
    "ReachCode",
    "FromNode",
    "ToNode",
    ST_AsText(geom) AS wkt
FROM
    "{0}"."StreamCenterlines"
WHERE
    "ReachCode" IS NOT NULL;
'''
        qry = qry.format(self.schema)
        reaches = self.rgis.rdb.run_query(qry, fetch=True)
        return reaches

    def build_network(self):
        net_all = 'BEGIN STREAM NETWORK:\n'
        net_node = '   ENDPOINT: {0:f}, {1:f}, 0, {2}\n'
        net_reach = '''
   REACH:
      STREAM ID: {0}
      REACH ID: {1}
      FROM POINT: {2}
      TO POINT: {3}
      CENTERLINE:
{4}   END:
'''
        net_centerline = '         {0}, {1}, None\n'
        net_end = '\nEND STREAM NETWORK:\n\n'
        nodes = self.get_nodes()
        reaches = self.get_reaches()
        for node in nodes:
            net_all += net_node.format(node['X'], node['Y'], node['NodeID'])
        for reach in reaches:
            centerlines = ''
            pnts = RasGisImport.unpack_wkt(reach['wkt'])
            for pt in pnts:
                x, y = pt
                centerlines += net_centerline.format(x, y)
            net_all += net_reach.format(reach['RiverCode'], reach['ReachCode'], reach['FromNode'], reach['ToNode'], centerlines)
        net_all += net_end
        return net_all


class XSBuilder(object):
    """
     Return CROSS SECTIONS part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_xsections(self):
        qry = '''
SELECT
    "XsecID",
    "RiverCode",
    "ReachCode",
    "Station",
    "LeftBank",
    "RightBank",
    "LLength",
    "ChLength",
    "RLength",
    ST_AsText(geom) AS wkt
FROM
    "{0}"."XSCutLines";
'''
        qry = qry.format(self.schema)
        xsections = self.rgis.rdb.run_query(qry, fetch=True)
        if xsections is None:
            return []
        else:
            return xsections

    def get_nvalues(self, xs_id):
        qry = 'SELECT "Fraction", "N_Value" FROM "{0}"."Manning" WHERE "XsecID" = {1};'
        qry = qry.format(self.schema, xs_id)
        nvalues = self.rgis.rdb.run_query(qry, fetch=True)
        if nvalues is None:
            return []
        else:
            return nvalues

    def get_levee_points(self, xs_id):
        qry = 'SELECT "LeveeID", "Fraction", "Elevation" FROM "{0}"."LeveePoints" WHERE "XsecID" = {1};'
        qry = qry.format(self.schema, xs_id)
        levee_points = self.rgis.rdb.run_query(qry, fetch=True)
        if levee_points is None:
            return []
        else:
            return levee_points

    def get_ineffs(self, xs_id):
        qry = 'SELECT "IneffID", "FromFract", "ToFract", "Elevation" FROM "{0}"."IneffLines" WHERE "XsecID" = {1};'
        qry = qry.format(self.schema, xs_id)
        ineffs = self.rgis.rdb.run_query(qry, fetch=True)
        if ineffs is None:
            return []
        else:
            return ineffs

    def get_blocks(self, xs_id):
        qry = 'SELECT "BlockID", "FromFract", "ToFract", "Elevation" FROM "{0}"."BlockLines" WHERE "XsecID" = {1};'
        qry = qry.format(self.schema, xs_id)
        blocks = self.rgis.rdb.run_query(qry, fetch=True)
        if blocks is None:
            return []
        else:
            return blocks

    def get_surf(self, xs_id):
        qry = 'SELECT ST_X(geom) AS x, ST_Y(geom) AS y, "Elevation" FROM "{0}"."XSSurface" WHERE "XsecID" = {1} ORDER BY "Station";'
        qry = qry.format(self.schema, xs_id)
        surfs = self.rgis.rdb.run_query(qry, fetch=True)
        if surfs is None:
            return []
        else:
            return surfs

    def build_cross_sections(self):
        xsec_all = 'BEGIN CROSS-SECTIONS:\n'
        xsec_nval = '         {0}, {1}\n'
        xsec_levee_points = '         {0}, {1}, {2}\n'
        xsec_ineff = '         {0}, {1}, {2}, {3}\n'
        xsec_block = '         {0}, {1}, {2}, {3}\n'
        xsec_cut = '         {0}, {1}\n'
        xsec_surf = '         {0}, {1}, {2}\n'
        xsec_cross = '''
   CROSS-SECTION:
      STREAM ID:{6}
      REACH ID:{7}
      STATION:{8}
      NODE NAME:
      BANK POSITIONS: {9}, {10}
      REACH LENGTHS: {11}, {12}, {13}
      NVALUES:
{0}   LEVEE POSITIONS:
{1}   INEFFECTIVE POSITIONS:
{2}   BLOCKED POSITIONS:
{3}   CUT LINE:
{4}   SURFACE LINE:
{5}   END:
'''
        xsec_end = '\nEND CROSS-SECTIONS:\n\n'
        for cs in self.get_xsections():
            xs_id = cs['XsecID']
            attrs = cs[1:-1]
            nvalues = ''
            levee_points = ''
            ineffs = ''
            blocks = ''
            cuts = ''
            surfs = ''
            for n in self.get_nvalues(xs_id):
                nvalues += xsec_nval.format(n['Fraction'], n['N_Value'])
            for l in self.get_levee_points(xs_id):
                levee_points += xsec_levee_points.format(l['LeveeID'], l['Fraction'], l['Elevation'])
            for i in self.get_ineffs(xs_id):
                ineffs += xsec_ineff.format(i['IneffID'], i['FromFract'], i['ToFract'], i['Elevation'])
            for b in self.get_blocks(xs_id):
                blocks += xsec_block.format(b['BlockID'], b['FromFract'], b['ToFract'], b['Elevation'])
            pnts = RasGisImport.unpack_wkt(cs['wkt'])
            for pt in pnts:
                x, y = pt
                cuts += xsec_cut.format(x, y)
            for s in self.get_surf(xs_id):
                surfs += xsec_surf.format(s['x'], s['y'], s['Elevation'])
            xsec_all += xsec_cross.format(nvalues, levee_points, ineffs, blocks, cuts, surfs, *attrs)
        xsec_all += xsec_end
        return xsec_all


class BridgesBuilder(object):
    """
    Return BRIDGES part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_bridges(self):
        qry = '''
SELECT
    "RiverCode",
    "ReachCode",
    "Station",
    "USDistance",
    "TopWidth",
    "NodeName"
    ST_AsText(geom) AS wkt
FROM
    "{0}"."Bridges";
'''
        qry = qry.format(self.schema)
        bridges = self.rgis.rdb.run_query(qry, fetch=True)
        if bridges is None:
            return []
        else:
            return bridges

    def build_bridges(self):
        bridges_all = 'BEGIN BRIDGES/CULVERTS:\n'
        bridge_obj = '''
   BRIDGE/CULVERT:
      STREAM ID: {0}
      REACH ID: {1}
      STATION: {2}
      NODE NAME: {3}
      US DISTANCE: {4}
      TOP WIDTH: {5}
      CUT LINE:
{6}   SURFACE LINE:
{7}   END:
'''
        bridge_cut = '         {0}, {1}\n'
        bridge_surf = '         {0}, {1}, {2}\n'
        bridges_end = '\nEND BRIDGES/CULVERTS:\n\n'


class LeveesBuilder(object):
    """
     Return LEVEES part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_levees(self):
        qry = 'SELECT "LeveeID", ST_AsText(geom) AS wkt FROM "{0}"."LeveeAlignment";'
        qry = qry.format(self.schema)
        levees = self.rgis.rdb.run_query(qry, fetch=True)
        if levees is None:
            return []
        else:
            return levees

    def build_levees(self):
        levees_all = 'BEGIN LEVEES:\n'
        levee_object = '''
   LEVEE ID: {0}
      SURFACE LINE:
{1}   END:
'''
        levees_surf = '         {0}, {1}, None\n'
        levees_end = '\nEND LEVEES:\n\n'
        for l in self.get_levees():
            surfs = ''
            levee_id = l['LeveeID']
            pnts = RasGisImport.unpack_wkt(l['wkt'])
            for pt in pnts:
                x, y = pt
                surfs += levees_surf.format(x, y)
            levees_all += levee_object.format(levee_id, surfs)
        levees_all += levees_end
        return levees_all


class IneffAreasBuilder(object):
    """
     Return Ineffective Areas part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_ineffective_areas(self):
        qry = 'SELECT "IneffID", ST_AsText(geom) AS wkt FROM "{0}"."IneffAreas";'
        qry = qry.format(self.schema)
        ineff_areas = self.rgis.rdb.run_query(qry, fetch=True)
        if ineff_areas is None:
            return []
        else:
            return ineff_areas

    def build_ineff_areas(self):
        ineff_all = 'BEGIN INEFFECTIVE AREAS:\n'
        ineff_poly = '''
   INEFFECTIVE ID: {0}
      POLYGON:
{1}   END:
'''
        ineff_vertex = '         {0}, {1}\n'
        ineff_end = '\nEND INEFFECTIVE AREAS:\n\n'
        for i in self.get_ineffective_areas():
            vertices = ''
            ineff_id = i['IneffID']
            pnts = RasGisImport.unpack_wkt(i['wkt'])
            for pt in pnts:
                x, y = pt
                vertices += ineff_vertex.format(x, y)
            ineff_all += ineff_poly.format(ineff_id, vertices)
        ineff_all += ineff_end
        return ineff_all


class BlockedObsBuilder(object):
    """
     Return Blocked Obstructions part of RAS GIS Import file.
    """
    def __init__(self, rgis):
        self.rgis = rgis
        self.schema = rgis.rdb.SCHEMA

    def get_blocked_obstructions(self):
        qry = 'SELECT "BlockID", ST_AsText(geom) AS wkt FROM "{0}"."BlockedObs";'
        qry = qry.format(self.schema)
        block_obs = self.rgis.rdb.run_query(qry, fetch=True)
        if block_obs is None:
            return []
        else:
            return block_obs

    def build_blocked_obs(self):
        block_all = 'BEGIN BLOCKED OBSTRUCTIONS:\n'
        block_poly = '''
   BLOCKED ID: {0}
      POLYGON:
{1}   END:
'''
        block_vertex = '         {0}, {1}\n'
        block_end = '\nEND BLOCKED OBSTRUCTIONS:\n\n'
        for b in self.get_blocked_obstructions():
            vertices = ''
            block_id = b['BlockID']
            pnts = RasGisImport.unpack_wkt(b['wkt'])
            for pt in pnts:
                x, y = pt
                vertices += block_vertex.format(x, y)
            block_all += block_poly.format(block_id, vertices)
        block_all += block_end
        return block_all
